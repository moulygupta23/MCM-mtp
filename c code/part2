int l = prob->l;
	int w_size = prob->n;
	int i, s, iter = 0;
	double C, da,db, Ga,Gb;
	double *QD = new double[l];
	int max_iter = 1000;
	int *index = new int[l];
	double *alpha = new double[l];
	double *beta = new double[l];
	schar *y = new schar[l];
	int active_size = l;
	double lambda = 4;

	// PG: projected gradient, for shrinking and stopping
	double PGa;
	double PGamax_old = INF;
	double PGamin_old = -INF;
	double PGamax_new, PGamin_new;

	double PGb;
	double PGbmax_old = INF;
	double PGbmin_old = -INF;
	double PGbmax_new, PGbmin_new;

	// default solver_type: L2R_L2LOSS_SVC_DUAL
	double diag[3] = {0.5/Cn, 0, 0.5/Cp};
	double upper_bound[3] = {INF, 0, INF};
	if(solver_type == L2R_L1LOSS_SVC_DUAL)
	{
		diag[0] = 0;
		diag[2] = 0;
		upper_bound[0] = Cn;
		upper_bound[2] = Cp;
	}

	for(i=0; i<l; i++)
	{
		
		if(prob->y[i] > 0)
		{
			y[i] = +1;
		}
		else
		{
			y[i] = -1;
		}
		feature_node * const xi = prob->x[i];
		// info("%d ",y[i]);
		// printx(xi);
		// info("\n");
	}

	// Initial alpha can be set here. Note that
	// 0 <= alpha[i] <= upper_bound[GETI(i)]
	for(i=0; i<l; i++){
		alpha[i] = 1.0/l;
		beta[i] = 0;
	}

	for(i=0; i<w_size; i++)
		w[i] = 0;
	for(i=0; i<l; i++)
	{
		QD[i] = diag[GETI(i)];

		feature_node * const xi = prob->x[i];
		QD[i] += sparse_operator::nrm2_sq(xi);
		sparse_operator::axpy(y[i]*(beta[i]-alpha[i]), xi, w);

		index[i] = i;
	}

	// for(int i=0; i<l; i++){
	// 	info("%lf ",QD[i]);
	// }
	// info("\n\n");
	// info("w = ");
	// for(int i=0;i<w_size;i++)
	// 	info("%lf ",w[i]);
	// info("\n");
	while (iter < max_iter)
	{
		PGamax_new = -INF;
		PGamin_new = INF;

		PGbmax_new = -INF;
		PGbmin_new = INF;

		// for (i=0; i<active_size; i++)
		// {
		// 	int j = i+rand()%(active_size-i);
		// 	swap(index[i], index[j]);
		// }

		for (s=0; s<active_size; s++)
		{
			i = index[s];
			const schar yi = y[i];
			feature_node * const xi = prob->x[i];

			Gb = yi*sparse_operator::dot(w, xi)-1;

			C = upper_bound[GETI(i)];
			Gb += (beta[i]+alpha[i])*diag[GETI(i)];

			Ga = lambda - Gb -1 +(beta[i] + alpha[i])*diag[GETI(i)];
			// info("%lf %lf ",Ga,Gb);
			PGa = 0;
			PGb = 0;

			if (alpha[i] == 0)
			{
				if (Ga > PGamax_old)
				{
					active_size--;
					swap(index[s], index[active_size]);
					s--;
					continue;
				}
				else if (Ga < 0)
					PGa = Ga;
			}
			else if (alpha[i] == C)
			{
				if (Ga < PGamin_old)
				{
					active_size--;
					swap(index[s], index[active_size]);
					s--;
					continue;
				}
				else if (Ga > 0)
					PGa = Ga;
			}
			else
				PGa = Ga;

			PGamax_new = max(PGamax_new, PGa);
			PGamin_new = min(PGamin_new, PGa);

			if (beta[i] == 0)
			{
				if (Gb > PGbmax_old)
				{
					active_size--;
					swap(index[s], index[active_size]);
					s--;
					continue;
				}
				else if (Gb < 0)
					PGb = Gb;
			}
			else if (beta[i] == C)
			{
				if (Gb < PGbmin_old)
				{
					active_size--;
					swap(index[s], index[active_size]);
					s--;
					continue;
				}
				else if (Gb > 0)
					PGb = Gb;
			}
			else
				PGb = Gb;

			PGbmax_new = max(PGbmax_new, PGb);
			PGbmin_new = min(PGbmin_new, PGb);
			da=0,db=0;
			if(fabs(PGa) > 1.0e-12)
			{
				double alpha_old = alpha[i];
				alpha[i] = min(max(alpha[i] - Ga/QD[i], 0.0), C);
				da = (alpha[i] - alpha_old)*yi;
			}

			if(fabs(PGb) > 1.0e-12)
			{
				double beta_old = beta[i];
				beta[i] = min(max(beta[i] - Gb/QD[i], 0.0), C);
				db = (beta[i] - beta_old)*yi;
			}

			if(fabs(PGa) > 1.0e-12 || fabs(PGb) > 1.0e-12){
				sparse_operator::axpy((db-da), xi, w);
			}
			// info("%lf %lf\n",alpha[i],beta[i]);
		}

		// info("\n\n\n");
		iter++;
		if(iter % 10 == 0)
			info(".");

		if(PGamax_new - PGamin_new <= eps && PGbmax_new - PGbmin_new <= eps)
		{
			if(active_size == l)
				break;
			else
			{
				active_size = l;
				info("*");
				PGamax_old = INF;
				PGamin_old = -INF;
				PGbmax_old = INF;
				PGbmin_old = -INF;
				continue;
			}
		}
		PGamax_old = PGamax_new;
		PGamin_old = PGamin_new;
		PGbmax_old = PGbmax_new;
		PGbmin_old = PGbmin_new;

		if (PGamax_old <= 0)
			PGamax_old = INF;
		if (PGamin_old >= 0)
			PGamin_old = -INF;

		if (PGbmax_old <= 0)
			PGbmax_old = INF;
		if (PGbmin_old >= 0)
			PGbmin_old = -INF;
	}

	info("\noptimization finished, #iter = %d\n",iter);
	if (iter >= max_iter)
		info("\nWARNING: reaching max number of iterations\nUsing -s 2 may be faster (also see FAQ)\n\n");

	// calculate objective value

	double v = 0;
	int nSV = 0;
	double sumalpha=0;
	for(i=0; i<w_size; i++)
		v += w[i]*w[i];
	for(i=0; i<l; i++)
	{	
		sumalpha+=alpha[i];
		v += alpha[i]*(alpha[i]*diag[GETI(i)] - 2);
		if((beta[i]-alpha[i]) != 0)
			++nSV;
		std::cout<<alpha[i]<<" "<<beta[i]<<std::endl;
	}
	info("Objective value = %lf\n",v/2);
	info("nSV = %d\n",nSV);
	info("sum of alpha = %lf\n",sumalpha);

	delete [] QD;
	delete [] alpha;
	delete [] y;
	delete [] index;